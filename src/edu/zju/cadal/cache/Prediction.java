package edu.zju.cadal.cache;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import edu.zju.cadal.model.Annotation;
import edu.zju.cadal.model.Candidate;
import edu.zju.cadal.model.Entity;
import edu.zju.cadal.model.Mention;
import edu.zju.cadal.model.NIL;

/**
 * Prediction class is the cache for storing results generated by an ERD system.
 * Cached results:
 * 	+ generated mentions
 *  + generated candidates
 *  + generated annotations
 *  + generated NILs
 *  + generated entities
 *  + the cost time for the ERD task 
 * @author:chenhui 
 * @email:chenhuicn@126.com
 * @date:2015年11月15日
 */
public class Prediction implements Serializable {

	private static final long serialVersionUID = 1L;
	private static Prediction prediction = new Prediction();
	
	/** The path of the cache file*/
	private static String cachePath = "cache/result.cache";
	private static File cacheFile = null;
	
	/** The flag of whether the cache is opened*/
	private static boolean cacheOpened = false;
	
	//存储annotation任务的结果，Map<系统名字+数据集名字,Map<文档title,title对应的annotation集合>>
	/** Map<ERD system's name + dataset's name, Map<document title, Set<Annotation>>> */
	private Map<String, Map<String, Set<Annotation>>> annotation 
					= new HashMap<String, Map<String,Set<Annotation>>>();
	private Map<String, Map<String, Set<Mention>>> mention 
					= new HashMap<String, Map<String,Set<Mention>>>();
	private Map<String, Map<String, Set<NIL>>> NIL 
					= new HashMap<String, Map<String,Set<NIL>>>();
	private Map<String, Map<String, Set<Candidate>>> candidate 
					= new HashMap<String, Map<String,Set<Candidate>>>();
	private Map<String, Map<String, Set<Entity>>> entity 
					= new HashMap<String, Map<String,Set<Entity>>>();
	private Map<String, Map<String, Long>> costTime 
					= new HashMap<String, Map<String,Long>>();
	
	private Prediction() { }
	
	/** Flush the cache to the cache file only if the flag is true*/
	public void flush()	{
		if (cacheOpened) {
			try {
				cacheFile.createNewFile();
				ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(cacheFile));
				oos.writeObject(prediction);
				oos.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
		
	}
	
	/**
	 * 加载结果，cache为true表示加载缓存结果
	 * Load cached results from the cache file and fill in the Prediction instance  
	 * @param cached, the flag of whether cache is opened 
	 * @return Prediction instance
	 */
	public static Prediction getInstance(boolean cached) {
		cacheOpened = cached;
		if (cached == true) {
			cacheFile = new File(cachePath);
			if (cacheFile.exists() && cacheFile.length() > 0) {
				try {
					prediction = (Prediction)new ObjectInputStream(new FileInputStream(cacheFile)).readObject();
				} catch (ClassNotFoundException | IOException e) {
					throw new RuntimeException(
							"Could Not Load Cache File "
									+ cacheFile.getAbsolutePath()
									+ ". Try to Manually Delete The File to Clear The Cache. Message: "
									+ e.getMessage());
				}
			}				
		}
		return prediction;
	}
	
	/**
	 * 是否缓存通过annotationCache来判断
	 * Check if the results of an ERD system and a dataset is cached through the annotationCache variable
	 * @param systemName, the name of an ERD system
	 * @param datasetName, the name of a dataset
	 * @return boolean value 
	 */
	public boolean isCached(String systemName, String datasetName) {
		if (cacheOpened == false || this.annotation.get(systemName+datasetName) == null)
			return false;
		return true;
	}
	
	/**
	 * 返回特定某个系统的annotation结果
	 * Get cached annotations according to the given ERD system and dataset
	 * @param systemName
	 * @param datasetName
	 * @return 
	 */
	public Map<String, Set<Annotation>> getAnnotationCache(String systemName, String datasetName) {
		return annotation.get(systemName + datasetName);
	}
	
	/**
	 * 返回特定系统大于给定threshold的annotation结果
	 * Get cached annotations whose confidence scores are larger than the given threshold.
	 * @param systemName
	 * @param datasetName
	 * @param threshold
	 * @return
	 */
	public Map<String, Set<Annotation>> getAnnotationCache(String systemName, String datasetName, float threshold) {
		Map<String, Set<Annotation>> retMap = new HashMap<String, Set<Annotation>>();
		Map<String, Set<Annotation>> resultMap = this.annotation.get(systemName + datasetName);
		for (String title : resultMap.keySet()) 
		{
			for (Annotation a : resultMap.get(title)) 
			{
				if (retMap.containsKey(title) == false)
					retMap.put(title, new HashSet<Annotation>());
				
				if (a.getScore() >= threshold)
					retMap.get(title).add(a);
			}
		}
		return retMap;
	}

	public void setAnnotationCache(String systemName, String datasetName, Map<String, Set<Annotation>> annotationMap) {
		this.annotation.put(systemName+datasetName, annotationMap);
		
	}

	public Map<String, Set<Mention>> getMentionCache(String systemName, String datasetName) {
		return mention.get(systemName + datasetName);
	}

	public Map<String, Set<Mention>> getMentionCache(String systemName, String datasetName, float threshold) {
		Map<String, Set<Mention>> retMap = new HashMap<String, Set<Mention>>();
		Map<String, Set<Mention>> resultMap = this.mention.get(systemName + datasetName);
		for (String title : resultMap.keySet()) {
			for (Mention m : resultMap.get(title)) {
				if (retMap.containsKey(title) == false)
					retMap.put(title, new HashSet<Mention>());
				
				if (m.getScore() >= threshold) 
					retMap.get(title).add(m);
			}
		}
		return retMap;
	}
	
	
	public void setMentionCache(String systemName, String datasetName, Map<String, Set<Mention>> mentionCache) {
		this.mention.put(systemName + datasetName, mentionCache);
	}

	public Map<String, Set<NIL>> getNILCache(String systemName, String datasetName) {
		return NIL.get(systemName + datasetName);
	}
	
	public Map<String, Set<NIL>> getNILCache(String systemName, String datasetName, float threshold) {
		Map<String, Set<NIL>> retMap = new HashMap<String, Set<NIL>>();
		Map<String, Set<NIL>> resultMap = this.NIL.get(systemName + datasetName);
		
		for (String title : resultMap.keySet()) { 
			if (retMap.containsKey(title) == false) {
				retMap.put(title, new HashSet<NIL>());
			}
			for (NIL n : resultMap.get(title)) {
				if (n.getScore() >= threshold)
					retMap.get(title).add(n);
			}
		}
		return retMap;
	}

	public void setNILCache(String systemName, String datasetName, Map<String, Set<NIL>> nILCache) {
		NIL.put(systemName + datasetName, nILCache);
	}

	public Map<String, Set<Candidate>> getCandidateCache(String systemName, String datasetName) {
		return candidate.get(systemName + datasetName);
	}
	
	public void setCandidateCache(String systemName, String datasetName, Map<String, Set<Candidate>> candidateCache) {
		this.candidate.put(systemName + datasetName, candidateCache);
	}
	
	public Map<String, Set<Entity>> getEntityCache(String systeName, String datasetName) {
		return this.entity.get(systeName + datasetName);
	}
	
	public void setEntityCache(String systemName, String datasetName, Map<String, Set<Entity>> entityMap) {
		this.entity.put(systemName + datasetName, entityMap);
	}

	public Map<String, Long> getCostTime(String systemName, String datasetName) {
		return costTime.get(systemName + datasetName);
	}

	public void setCostTime(String systemName, String datasetName, Map<String, Long> costTime) {
		this.costTime.put(systemName + datasetName, costTime);
	}
	
	public void remove(String systemName, String datasetName) {
		if (this.mention.containsKey(systemName+datasetName))
			this.mention.remove(systemName+datasetName);
		if (this.candidate.containsKey(systemName+datasetName))
			this.candidate.remove(systemName+datasetName);
		if (this.entity.containsKey(systemName+datasetName))
			this.entity.remove(systemName+datasetName);
		if (this.annotation.containsKey(systemName+datasetName))
			this.annotation.remove(systemName+datasetName);
		if (this.NIL.containsKey(systemName+datasetName))
			this.NIL.remove(systemName+datasetName);
		if (this.costTime.containsKey(systemName+datasetName))
			this.costTime.remove(systemName+datasetName);
	}
	
}
