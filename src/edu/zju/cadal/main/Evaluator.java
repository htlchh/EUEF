package edu.zju.cadal.main;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;

import edu.zju.cadal.cache.PRF;
import edu.zju.cadal.matching.Matching;

/**
 * 
 * The Evaluation Executor
 * Given the predictions generated by an ERD system and the gold standards,
 * it computes the precision, recall and F1 with the given matching metric. 
 * 
 * @author:chenhui 
 * @email:chenhuicn@126.com
 * @date:2015年11月16日
 */
public class Evaluator<T> {

	public static <T> PRF getResult(
			Map<String, Set<T>> prediction, 
			Map<String, Set<T>> goldStandard,
			Matching<T> m)
	{
		m.preProcessing(prediction, goldStandard);
		Map<String, Integer> tpMap = tp(prediction, goldStandard, m);
		Map<String, Integer> fpMap = fp(prediction, goldStandard, m);
		Map<String, Integer> fnMap = fn(prediction, goldStandard, m);
		int tpCount = countTP(tpMap);
		int fpCount = countFP(fpMap);
		int fnCount = countFN(fnMap);
		Map<String, Float> precisionMap = precision(tpMap, fpMap);
		Map<String, Float> recallMap = recall(tpMap, fnMap);
		Map<String, Float> f1Map = f1(precisionMap, recallMap);
		float microPrecision = microPrecision(tpCount, fpCount);
		float microRecall = microRecall(tpCount, fnCount);
		float microF1 = microF1(microRecall, microPrecision);
		float macroPrecision = macroPrecision(precisionMap);
		float macroRecall = macroRecall(recallMap);
		float macroF1 = macroF1(macroPrecision, macroRecall);
		
		return new PRF(
				microF1, microRecall, microPrecision,
				macroF1, macroRecall, macroPrecision, 
				tpCount, fnCount, fpCount, 
				precisionMap, recallMap, f1Map, 
				tpMap, fpMap, fnMap);		
	}

	
	/**
	 * Get the false negatives
	 * 
	 * @param prediction
	 * @param goldStandard
	 * @param m
	 * @return
	 */
	private static <T> Map<String, Integer> fn(Map<String, Set<T>> prediction, Map<String, Set<T>> goldStandard, Matching<T> m) {
		Map<String, Integer> fnMap = new HashMap<String, Integer>();
		for (String title : goldStandard.keySet()) {
			int fn = getSingleFN(prediction.get(title), goldStandard.get(title), m);
			fnMap.put(title, fn);
		}
		return fnMap;
	}

	private static <T> int getSingleFN(Set<T> prediction, Set<T> goldStandard, Matching<T> m) {
		int fn = 0;
		for (T g : goldStandard) {
			boolean matched = false;
			for (T s : prediction) {
				if (m.match(s, g) == true) {
					matched = true;
					break;
				}
			}
			if (matched == false) {
				fn++;
			}
		}
		return fn;
	}

	/**
	 * Get the false positives
	 */
	private static <T> Map<String, Integer> fp(Map<String, Set<T>> prediction, Map<String, Set<T>> goldStandard, Matching<T> m) {
		Map<String, Integer> fpMap = new HashMap<String, Integer>();
		for (String title : goldStandard.keySet()) {
			int fp = getSingleFP(prediction.get(title), goldStandard.get(title), m);
			fpMap.put(title, fp);
		}
		return fpMap;
	}

	private static <T> int getSingleFP(Set<T> prediction, Set<T> goldStandard, Matching<T> m) {
		int fp = 0;
		for (T s : prediction) {
			boolean matched = false;
			for (T g : goldStandard)
				if (m.match(s, g) == true) {
					matched = true;
					break;
				}
			if (matched == false)
				fp++;
		}
		return fp;
	}

	/**
	 * Get the true positives
	 */
	private static <T> Map<String, Integer> tp(Map<String, Set<T>> prediction, Map<String, Set<T>> goldStandard, Matching<T> m) {
		Map<String, Integer> tpMap = new HashMap<String, Integer>();
		for (String title : prediction.keySet()) {
			int tp = getSingleTP(prediction.get(title), goldStandard.get(title), m);
			tpMap.put(title, tp);
		}
		return tpMap;
	}

	private static <T> int getSingleTP(Set<T> prediction, Set<T> goldStandard, Matching<T> m) {
		int tp = 0;
		for (T g : goldStandard)
			for (T s : prediction)
				if (m.match(g, s) == true) {
					tp++;
					break;
				}
		return tp;
	}


	private static <T> int countFP(Map<String, Integer> fpMap) {
		int fp = 0;
		for (String title : fpMap.keySet()) 
			fp += fpMap.get(title);
		return fp;
	}

	/**
	 * Count the false negatives of the whole dataset
	 */
	private static <T> int countFN(Map<String, Integer> fnMap) {
		int fn = 0;
		for (String title : fnMap.keySet()) 
			fn += fnMap.get(title);
		return fn;
	}

	/**
	 * Count the true positives of the whole dataset
	 */
	private static <T> int countTP(Map<String, Integer> tpMap) {
		int tp = 0;
		for (String title : tpMap.keySet()) 
			tp += tpMap.get(title);
		return tp;
	}
	
	/** Compute recall for the whole dataset */
	private static <T> Map<String, Float> recall(Map<String, Integer> tpMap, Map<String, Integer> fnMap) {
		Map<String, Float> recallMap = new HashMap<String, Float>();
		for (String title : tpMap.keySet()) {
			float recall = tpMap.get(title) + fnMap.get(title) == 0
							? 1 
							: (float)tpMap.get(title) / (tpMap.get(title) + fnMap.get(title));
			recallMap.put(title, recall);
		}
		return recallMap;
	}
	

	private static <T> Map<String, Float> precision(Map<String, Integer> tpMap, Map<String, Integer> fpMap) {
		Map<String, Float> precisionMap = new HashMap<String, Float>();
		for (String title : tpMap.keySet()) {
			float precision = tpMap.get(title) + fpMap.get(title) == 0 
							  ? 1
							  : (float)tpMap.get(title) / (tpMap.get(title) + fpMap.get(title));
			precisionMap.put(title, precision);
		}
		return precisionMap;
	}
	
	private static <T> Map<String, Float> f1(Map<String, Float> precisionMap, Map<String, Float> recallMap) {
		Map<String, Float> f1Map = new HashMap<String, Float>();
		for (String title :precisionMap.keySet()) {
			float f1 = (precisionMap.get(title) + recallMap.get(title)) == 0
					? 0
					: 2 * precisionMap.get(title) * recallMap.get(title) / (precisionMap.get(title) + recallMap.get(title));
			f1Map.put(title, f1);
		}
		return f1Map;
	}
	
	private static <T> float macroRecall(Map<String, Float> recallMap) {
		float recall = 0.0f;
		for (String title : recallMap.keySet())
			recall += recallMap.get(title);
		return recall / recallMap.size();
	}
	
	private static <T> float macroPrecision(Map<String, Float> precisionMap) {
		float precision = 0.0f;
		for (String title : precisionMap.keySet())
			precision += precisionMap.get(title);
		return precision / precisionMap.size();
	}

	private static <T> float macroF1(float macroPrecision, float macroRecall) {
		return (macroPrecision + macroRecall == 0) 
					? 0 
					: 2 * macroPrecision * macroRecall / (macroPrecision + macroRecall);
	}

	private static <T> float microF1(float recall, float precision) {
		return (recall + precision == 0) 
				? 0 
				: 2 * recall * precision / (recall + precision);
	}

	private static <T> float microRecall(int tp, int fn) {
		return fn + tp == 0 
				? 1 
				: (float) tp / (float) (fn + tp);
	}

	private static <T> float microPrecision(int tp, int fp) {
		return tp + fp == 0 
				? 1 
				: (float) tp / (float) (tp + fp);
	}

}
